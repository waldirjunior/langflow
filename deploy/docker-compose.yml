services:
  backend:
    image: "langflowai/langflow-backend:latest"
    depends_on:
      - db
      - broker
      - result_backend
    env_file:
      - .env
    # Adicionamos a porta para que o Nginx possa acessar o backend.
    # A porta 7860 do host será mapeada para a porta 7860 do contêiner.
    ports:
      - "127.0.0.1:7860:7860" # Expondo apenas para o localhost (host machine) por segurança
    healthcheck:
      test: "exit 0"
    restart: unless-stopped # Adicionado para garantir que o serviço reinicie se cair

  db:
    image: postgres:15.4
    volumes:
      - app-db-data:/var/lib/postgresql/data/pgdata
    environment:
      - PGDATA=/var/lib/postgresql/data/pgdata
    healthcheck:
      test: "exit 0"
    env_file:
      - .env
    restart: unless-stopped

  pgadmin:
    image: dpage/pgadmin4
    volumes:
      - pgadmin-data:/var/lib/pgadmin
    env_file:
      - .env
    # Se quiser acessar o pgadmin via Nginx, adicione a porta. Ex:
    ports:
      - "127.0.0.1:5050:80" # A porta interna do pgadmin é 80
    restart: unless-stopped

  result_backend:
    image: redis:6.2.5
    env_file:
      - .env
    # A porta 6379 não precisa ser exposta ao host, os outros contêineres a acessam internamente.
    healthcheck:
      test: "exit 0"
    restart: unless-stopped

  celeryworker:
    image: "langflowai/langflow-backend:latest" # Usa a mesma imagem do backend
    depends_on:
      - backend
    env_file:
      - .env
    command: /bin/sh -c "python -m celery -A langflow.worker.celery_app worker --loglevel=INFO --concurrency=1 -n lf-worker@%h -P eventlet"
    healthcheck:
      test: "exit 0"
    deploy: # A seção deploy é mais usada em modo Swarm, mas para réplicas funciona aqui.
      replicas: 1
    restart: unless-stopped

  flower:
    image: "langflowai/langflow-backend:latest" # Usa a mesma imagem do backend
    depends_on:
      - backend
    env_file:
      - .env
    environment:
      - FLOWER_PORT=5555
    command: /bin/sh -c "python -m celery -A langflow.worker.celery_app --broker=${BROKER_URL?Variable not set} flower --port=5555"
    # Se quiser acessar o Flower via Nginx, adicione a porta. Ex:
    ports:
      - "127.0.0.1:5555:5555"
    restart: unless-stopped

  frontend:
    image: "langflowai/langflow-frontend:latest"
    env_file:
      - .env
    # Adicionamos a porta para que o Nginx possa acessar o frontend.
    # A porta 8080 do host será mapeada para a porta 80 do contêiner.
    ports:
      - "127.0.0.1:8081:80" # Expondo apenas para o localhost por segurança
    restart: unless-stopped

  broker:
    image: rabbitmq:3-management
    environment:
      - RABBITMQ_DEFAULT_USER=${RABBITMQ_DEFAULT_USER:-admin}
      - RABBITMQ_DEFAULT_PASS=${RABBITMQ_DEFAULT_PASS:-admin}
    volumes:
      - rabbitmq_data:/var/lib/rabbitmq/
      - rabbitmq_log:/var/log/rabbitmq/
    # As portas 5672 (AMQP) e 15672 (management) não precisam ser expostas publicamente,
    # a menos que você queira acessar o painel de gerenciamento do RabbitMQ via Nginx.
    # Se quiser, descomente a linha abaixo e configure no Nginx:
    ports:
      - "127.0.0.1:15672:15672"
    restart: unless-stopped

  # Os serviços prometheus e grafana foram removidos das labels do traefik.
  # Se precisar acessá-los, exponha suas portas como nos outros exemplos.
  prometheus:
    image: prom/prometheus:v2.37.9
    env_file:
      - .env
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
    command:
      - "--config.file=/etc/prometheus/prometheus.yml"
    healthcheck:
      test: "exit 0"
    restart: unless-stopped

  grafana:
    image: grafana/grafana:8.2.6
    env_file:
      - .env
    volumes:
      - grafana_data:/var/lib/grafana
    ports:
      - "127.0.0.1:3000:3000"
    restart: unless-stopped

volumes:
  grafana_data:
  app-db-data:
  rabbitmq_data:
  rabbitmq_log:
  pgadmin-data:
